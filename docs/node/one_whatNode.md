# node是什么

## 到底什么是node
如果有人问你到底什么是`node`,可以用一句话来回答，因为这句话基本上包含了`node`的本质和其作用：

<font color=#3eaf7c>Node不是一门语言，也不是一个框架，是基于Chrome V8引擎的JavaScript运行时环境；同时结合libuv扩展了JavaScript的功能，使得JavaScript能够支持浏览器Dom的操作，同时具有了后端语言才有的I/O，文件读写和操作数据库的能力，是目前最简单的全栈环境</font>

因为大道至简，任何知识当你理解到一种程度的时候就可以用一句话来总结，但是实际上任何知识点如果你要开始学习它，都不是一句话能学的懂的，所以作为前端程序员我们首先要知道为什么`Node`选择了`JavaScript`，因为
+ <font color=#3eaf7c>语言的语法结构简单，进行数据提取和分析就越容易，用来开发互联网应用也就越简单，如果对象创建和线程管理都不是必须的，那么基于原型而不是面向对象的JavaScript就是最完美的</font>

这也印证了万维网之父Tim-Berners-Lee的那句话： 
+ <font color=#CC99CD>任何可以使用JavaScript实现的应用，最终都用JavaScript实现</font>

所以当你使用`node`时间久了你就会有这样一种感觉：<font color=#1E90FF>前端工程师在Chrome里写JavaScript控制浏览器，Node.js让你用类似的方式来控制整个计算机</font>

## node概述
在官网有段关于`node`的描述如下：

`Node.js is a JavaScript runtime built on Chrome's V8 engine. Node.js uses an event-driven , non-block I/O model that makes it lightweight and efficient, Node.js' package ecosystem,npm, is the largest ecosystem of open source libraries in the world`

+ 首先最重要的就是node的本质是`JavaScript`环境运行时，因为在过去`JavaScript`只能在浏览器当中运行，而因为浏览器当中有`JS引擎`，它可以帮助浏览器去识别和执行`JavaScript`语言，但是浏览器是每个不同厂家的产品，其实使用的引擎也不一样，而作为最近十年表现优异的`V8引擎`也帮助Chrome浏览器在市场独占鳌头，所以有人把它拿出来做了修改，让`V8引擎`可以单独运行在别的地方，也致使`JavaScript`脱离的浏览器也可以运行，所谓环境运行时，就是`JavaScript`可以运行的平台。

+ `JavaScript`和`C++`有着千丝万缕的联系。因为`V8引擎`是通过`C++`来编写的，但是实际上这种底层语言的学习成本和使用成本都很大，我们编写的`JavaScript`实际上要转化成为这种`C++`去运行的，同时在`node`当中I/O都是异步的，全部要交给由`C++`编写的`libuv`这个事件循环库来处理，简化了并发模型。

+ `Node`的目标是让并发变的简单，而使用的这种<font color=#3eaf7c>事件循环</font>和<font color=#3eaf7c>非阻塞I/O模型</font>让在以网络编程为主的I/O密集的应用当中脱引而出。但是这两个名词概念有点生疏，我们下面来说一下这个两个概念。

### 1. 非阻塞I/O
首先`I/O`是`input`和`output`的缩写，表示计算机输入输出的意思，除了常见的键盘，显示器，打印机都是输入输出设备，对计算机来说读写磁盘和网络操作都是`I/O`操作，当然数据库的操作也算，因为数据库也在磁盘当中。

我们先来看看<font color=#CC99CD>阻塞I/O</font>：`I/O`的时候进程休眠等待`I/O`完成后进入下一步。如果不考虑跳转语句，普通的程序是逐条执行的，当程序走到`I/O`操作的时候，程序会调用操作系统更底层的命令来完成操作，期间程序就会等待底层命令返回结果。拿到结果才能进行下一条程序语句的执行，<font color=#3eaf7c>我们把程序等待底层命令结果返回的这种行为或者现象称之为阻塞</font>

<font color=#CC99CD>非阻塞I/O</font>：`I/O`时函数立即返回，进程不等待`I/O`完成。程序进行到`I/O`操作的时候，主程序开始调用底层命令，但是主程序并不会一直等待底层命令的返回，而是执行下一条程序语句。然后等到底层`I/O`有结果返回的时候，主程序再去决定丢弃还是处理。

但是计算机指令都可以理解为阻塞的，为什么偏偏`I/O`操作就是特殊的呢？简单来说: 大部分的指令都依赖于`CPU`运算，因为到当下来说`CPU`运行速度极其的快，一秒能执行30亿条语句，非`I/O`操作压根感觉不到阻塞，但是`I/O`操作更慢，比如拷贝电影文件，这都是肉眼看得见的慢。

### 2. 事件驱动
前面我们说`I/O`操作完成后主程序会感知到，但是一定会有一种机制，就是主程序啥时候知道`I/O`操作完成，或者说完成的结果以怎么样的方式告诉主程序？

非阻塞的`I/O`认为立即完成的，同时发射一个事件并写好这个事件的处理函数，底层`I/O`操作完成后触发这个事件并执行相关的处理函数，内部的实现实际上是一个<font color=#3eaf7c>观察者模式</font>

## node架构模式

<img :src="$withBase('/node_mode.jpg')" alt="node早期的架构">

首先`libuv`由<font color=#3eaf7c>事件循环</font>和<font color=#3eaf7c>线程池</font>组成，负责所有I/O任务的分发和执行 `Node.js`是由事件循环来分发I/O任务，由工作线程将人物分发到线程池当中，事件循环只需要等待执行结果即可。这就是`node`的架构模式，我们下面来解释一下为什么是这样：
+ 因为JS是单线程,单线程的特点就是同同一时间只能干一件事，所有任务都需要排队挨个执行。
+ 而CPU是空闲的，它完全可以不管I/O设备而直接挂起处于等待中的任务，先运行排在后面的任务
+ 将等待的I/O任务放在事件循环中，但是I/O任务分为<font color=#3eaf7c>文件I/O</font>和<font color=#3eaf7c>网络I/O</font>, 可以看到文件I/O是在线程池中进行的，而网络I/O是不通过线程池完成的。

## node的特点
`Node`由4个很重要的特点就是：<font color=#3eaf7c>适合构建WEB应用</font>、<font color=#3eaf7c>高性能</font>、 <font color=#3eaf7c>简单</font>、 <font color=#3eaf7c>可扩展</font>
### 1. 适合构建WEB应用
+ <font color=#CC99CD>构建网站</font>
  传统的开发都是一体式的，视图渲染还有数据库访问，基本上都在一个项目当中，和传统的`java`还有`php`没有太大区别;

+ <font color=#CC99CD>构建API</font>  
  多端应用将`API`接口开发推向了浪尖，各种风格的接口开发琳琅满目，比如<font color=#3eaf7c>GitHub V3版的RESTful API</font>、 <font color=#3eaf7c>微博API的自定义约定</font>，包括最新的<font color=#3eaf7c>GraphQL</font>。但是大型工程当中的`API`比较复杂，<font color=#3eaf7c>因此在后端的API接口开发上封装一层专门供前端使用的 API Proxy是很有必要的</font>。所以这个在后面我们也会讲。

+ <font color=#CC99CD>构建RPC服务</font>
  `RPC协议服务`也叫做远程过程调用，常见的做法就是将数据库访问返回的数据以`TCP`形式传输给调用方，在协议和传输上有明显的优势，比如像著名的`RPC`服务有`Java`版本的`Dubbo`。`Google`出品的跨语言`RPC`库`gRPC`,当然`Node`实现的`RPC`库也有很多，例如使用纯粹用`Node`实现的`DNode`,微服务工具集`Seneca`,跨语言的`gRPC`客户端，可以看出`Node`在微服务下的使用场景也是非常多的。

+ <font color=#CC99CD>前后端分离</font>
  前端分离的应用场景有：<font color=#3eaf7c>前端页面静态化（page static）</font>、<font color=#3eaf7c>前端页面服务化（PAAS）</font>、<font color=#3eaf7c>服务端渲染（SSR）</font>、<font color=#3eaf7c>渐进式Web应用（PWA）</font>

+ <font color=#CC99CD>适用于Serverless</font>
  有关运维，`API`快速开发，服务端渲染问题都能通过Serverless来解决，开发者不需要去关心运维，流量处理和容器编排，通过一个函数（函数内置RPC,缓存，配置等）就能完成所有开发，可以简单理解为`Serveless`是云计算的延时，而`Node.js`在这方面有得天独厚的优势。

### 2. 高性能
+ <font color=#CC99CD>执行速度开</font>
  构建在优秀的`V8`引擎上，执行速度在动态语言中算最快的

+ <font color=#CC99CD>天生异步</font>
  <font color=#3eaf7c>事件驱动</font>和<font color=#3eaf7c>非阻塞I/O</font>特性决定了必须要采用异步的方式，实际上<font color=#3eaf7c>每个I/O都是异步的</font>，因此集成到`libuv`中才会让开发者感觉不到并发的存在。

### 3. 简单可扩展
+ 语法简单，并发编程简单，部署运维简单，开发简单，可以使用大量的`npm`模块，也可以通过编写`C++`实现`CPU`密集型任务

## node和Web
上面我们说到`node`在`Web`这种高并发、I/O密集场景性能上优势很明显，下面我们就要好好说一说原因。

**1.I/O密集**

我们先说一下`I/O`密集和`CPU`密集，以及为什么`Web`属于`I/O`密集。
+ <font color=#CC99CD>CPU密集</font>：程序大部分用来做计算和逻辑处理，比如牙所，解压，加密，解密等等
+ <font color=#CC99CD>I/O密集</font>：程序大部分用来做存取设备，网络设施的一些读取操作，以及数据库的读取，比如文件操作，网络操作，数据库

**2.web常见场景**

然后为什么在`Web`常常属于`I/O`密集，我们来看看web常见场景；
+ <font color=#CC99CD>静态资源读取</font> 
  基本上网络当中静态资源的获取都是要从服务器上获取，服务器这些资源是放在服务器的硬盘上的，所以对于服务器就是静态资源读取，属于文件操作，属于`I/O`密集。

+ <font color=#CC99CD>数据库操作</font>
  动态数据和信息都是要读取数据库的，当然也有少部分的`CPU`处理，但是慢的还是`I/O`操作

+ <font color=#CC99CD>渲染页面</font>
  读取模板也是属于`I/O`操作，因为属于文件读取么

## 高并发应对之道
### 1. 进程和线程
+ <font color=#CC99CD>进程</font>：是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位
  这种解释简直不能理解，因为比如说我们的音乐播放器或者电影播放器都是一个程序，双击图标，这段程序就会在电脑的内存中执行，<font color=#3eaf7c>所以在内存当中运行的程序就是一个进程</font>，

+ <font color=#CC99CD>多进程</font>：启用多个进程，多个进程可以一起执行多个任务（好比一台电脑能同时听音乐和同时写代码）

+ <font color=#CC99CD>线程</font>：进程内一个相对独立，可调度的执行单元，与同属于一个进程当中的其他线程共享进程的资源

+ <font color=#CC99CD>多线程</font>：启动一个进程，在一个进程内启动多个线程，这样多个线程也可以一块执行多个任务（好比一个音乐播放器中，又能听音乐，又能同时发评论）

### 2. node工作模型
`node`的工作模型或者架构我们在上面已经说过了，有关<font color=#3eaf7c>事件循环</font>和<font color=#3eaf7c>费阻塞I/O</font>我们这里依然有必有再说一下，这次我们将用最通俗的语言来讲，并且解释为什么这种模型能面对高并发
<img :src="$withBase('/node_work.png')" alt="node工作模型">

在此之前我们先说说传统的`java apache`是怎么工作的。面对用户访问，它是每次一个用户访问进来就要开启一个进程，在这个进程中进行`CPU`对请求分析，然后再进行`I/O`操作。好比一个饭店是这样的工作模式，一个服务员配对一个大厨，这个服务员就是`CPU`,大厨就是`I/O`,他们属于一个进程里的东西，服务员点菜，然后交给同一个进程中的大厨去进行`I/O`操作。但是这个模式有两个特别明显的缺点：
+ <font color=#3eaf7c>一个服务器最大进程数有限</font> ，比如最大可以开5000个进程，那就说明同时只能处理5000个用户访问，第5001个用户就得等着（这就好比饭店中有30个服务员和30个大厨，第30个客人来就要等，等到哪个大厨做完才能开始点菜）
+ <font color=#3eaf7c>CPU被严重浪费</font> ，同时开5000个进程，一个进程完全处理一个请求需要10分钟，但是`CPU`处理的速度远远大于`I/O`,导致进程处于在`I/O`操作的时候，进程中分配的`CPU`是空闲的（好比服务员点菜需要一分钟，而大厨做菜需要30分钟，导致服务员在大厨做饭的时候没事干，玩手机）

相比之下，我们上图中`node`的工作模型就完美的解决了问题，面对用户的访问，只开一个单线程，这个单线程当中处理所有用户的请求分析，但是所有`I/O`的操作都交个多线程去做，这种模型就好比一个饭店只招一个服务员，但是有很多大厨，服务员可以不停的点菜，大厨可以不停的做菜，而且做好了就告诉服务员，服务员按号码给顾客上菜即可，当然顺序也是不一定，谁的菜先好了就给谁。这样的模型就不会怕客人多，服务员也不会空闲。虽然大厨做菜的这个时间是没有办法缩短的，但是服务员的利用率提高了，也就是`CPU`利用率提高了，同时无论多少客人来都不会等待点菜，只会等待做菜。

但是我们特别要注意的就是在上图这个模型中，事件循环（Event Lopp）是<font color=#3eaf7c>单线程</font>的，也就是只开一个进程，这个进程里只有一个线程。而非阻塞`I/O`(Non-blocking)是<font color=#3eaf7c>多线程</font>的，这里是操作系统在调度自己的多进程多进程，和`Node`开启的单线程没啥关系。<font color=#3eaf7c>所以Nodejs当中的单线程只针对主进程，I/O操作系统底层是多线程调度</font>

当然还有一个误区就是很多人认为`Node`没有办法使用多`CPU`,什么意思，就是很多小伙伴认为一个电脑有8核，起了一个`node`服务只占1核，剩下的7核都浪费了。实际上不是这样，因为在`node`当中有个`Cluster`的模块，专门解决多核并发问题，使用这个模块`cpu`有几个核我们就起几个进程。所以<font color=#3eaf7c>单线程并不是单进程</font>

### 3.高并发应对之道
高并发就是单位时间内的访问量比较大，我们来说一下从传统到现在的应对高并发的方法
+ <font color=#CC99CD>增加机器数</font>：相同大的流量，通过负载均衡分发到不同的机器上来应对高并发
+ <font color=#CC99CD>提高机器的质量</font>：计算需求高的提高`CPU`的核数和质量，然后`I/O`需求高的就买好一点的，硬盘质量好的机器。这种方法就和使用什么语言就没啥关系了
+ <font color=#3eaf7c>node完美解决高并发，I/O密集的Web场景</font>：node高性能的场景是一定有前提的，就是两个前提，一个高并发，一个`I/O`,试想一下如果是`CPU`密集，可以在事件循环处就卡住了，好比一个人上来就点满汉全席，一个一个菜挨着点，那服务员肯定会卡住的。