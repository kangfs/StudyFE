# node了不起
`Node`最开始是为了解决后端高并发而设计的，不想却成为了大前端领域的基石，而`Node`当下有了更多的应用场景，它的意义已经远远大于设计时候的初衷了，下面我们就来了解一下`Node`

## 架构升级
### 1. 从LAMP到MEAN

Web开发技术经过了两次比较大的架构演变，即从`LAMP`到`MEAN`
+ <font color=#CC99CD>LAMP</font>: `Linux`、`Apache`、`mysql`、`PHP`
+ <font color=#CC99CD>MEAN</font>: `Mongodb`、`Express`、`Angular`、`Node`

在微服务架构盛行的今天，`MEAN`已经因为技术栈过于复杂而被大家慢慢淡忘，更多的采用阿里巴巴开源的`Egg.js`,因为<font color=#3eaf7c>服务化才是流行的解决方案</font>，比如说`RPC`服务，服务组装还有页面即服务。

### 2. 前后端分离

绝大多数开发都是从<font color=#CC99CD>单体式架构</font>开始的，简单集成度高，上手十分容易，但是在团队协作重度化的今天，多人协作势必会导致专业化分工，<font color=#CC99CD>前后端分离也伴随而来</font>，典型的企业应用会采用三层架构模式：
+ <font color=#CC99CD>表现层</font>：处理`HTTP`请求，直接返回`HTML`渲染，或者返回`API`结果，对于复杂的应用系统，表面层通常是代码中比较重要的部分
+ <font color=#CC99CD>业务逻辑层</font>：完成具体的业务逻辑，是应用的核心组成部分
+ <font color=#CC99CD>数据访问层</font>：访问基础数据，例如数据库，缓存和消息队列

按照传统的分类方式，表现层就是前端，业务逻辑层和数据访问层都属于后端，而且现在重度API化的今天，后端业务逻辑被削弱了，更多业务逻辑可以被移到前端，比如说：<font color=#CC99CD>组装API</font>、<font color=#CC99CD>RPC服务</font>、<font color=#CC99CD>提供配置</font>、<font color=#CC99CD>静态API接口等等</font>，除了不直接操作数据库，前端都能承担。当前最常见的模式就是：<font color=#CC99CD>前端 + API + 后端服务</font>，如下所示：
+ <font color=#3eaf7c>用户客户端</font> -> <font color=#3eaf7c>请求</font> -> <font color=#3eaf7c>Nginx</font> -> <font color=#3eaf7c>node(前端Vue/React)</font> <- <font color=#3eaf7c>(json<-)静态API(->Ajax)</font> -> <font color=#3eaf7c>后端服务（node、java、Go）</font>

而上述为什么把前端`Vue/React`也列举为`node`呢，因为本质是使用`node`启动的服务，而单页面应用也是<font color=#CC99CD>页面即服务</font>的典型应用，因为前后端分离是比较大的话题，我们在下一个章节会展开来说

## 贯穿开发全过程
`Node`是了不起的，但是在做技术选型的时候，我们不应该只关注技术本身，更重要的是技术适合做什么，很多时候不是`Node`不行，而是没有用对，下面我们列出`Node`擅长的一些场景：
+ <font color=#CC99CD>大前端</font>：遵循`JavaScript`语法规则，使用`Node`做前后端分离
+ <font color=#CC99CD>API接口</font>：典型的`Web`应用，绝大多数都是`I/O`密集型应用，是`Node`最擅长的
+ <font color=#CC99CD>RPC服务</font>：主要针对于`OLTP`（联机事务处理过程）数据库进行操作

`Node`可以说贯穿了开发全过程，优化了各个环节，明显的提高开发效率，下面给出一些场景：

### 1. 静态API
静态`API`（也可以叫做Mock API）简单的说就是我们开发中的接口开发，那为什么叫静态的? <font color=#CC99CD>因为这种API的URL固定，前端请求的发送的请求JSON格式和后端响应的JSON格式或者风格都是固定的，所以这种能使前后端可以同时开始，而且不会产生扯皮的问题</font>

那么怎么实现静态`API`呢？就是我们最常用`Express`和`koa`框架，只不过因为在响应`Json`的风格上有很多，比如<font color=#CC99CD>GitHub v3 REST</font>风格、<font color=#CC99CD>微博自定义式风格</font>、还有流行的<font color=#CC99CD>GraphQL</font>风格的等等。

### 2. 现代Web开发
前端领域的空前火爆，目前前端还处于发展期，没有形成固定的模式，但是趋势就是上升的，复杂的，不过当前前端开发已经很复杂了，我们总结几个阶段：
+ 基础： HTML、CSS、JavaScript
+ 曾经流行：jQuery、Extjs、BackBone
+ 当前流行：Vue、React、Angular

对于`Node`来说，所有的前端框架都是视图上的展现层而已，可以非常方便的和各种框架无缝集成，所有的前端框架都采用了`Node`和`NPM`作为辅助开发工具，所以你如果熟悉掌握了`Node`和`npm`，对于前端技术的学习就只是纯前端的部分，其他技术复用价值很高。所以现代`Web`开发都是依靠`Node`模块的，我们可以简单的列举：

| 编号            | 分类          | 举例  |
| :-------------: |:-------------:| :-----:|
|1                | 压缩          | UglifyJS JSmin CSSO |
|2                | 依赖管理      | npm Bower |
|3                | 模块系统      | CommonJS AMD ES6module  |
|4                | 模块加载器    | Require.js jspm Sea.js System.js  |
|5                | 模块打包器    | Browerify Webpack |
|6                | css预处理器   | PostCss Less Sass stylus |
|7                | 构建工具      | Grunt Gulp |
|8                | 引擎模板      | Jade Handlebars Numjucks |
|9                | JavaScript友好语言  | CoffeeScipt Babel Typescript |
|10               | 跨平台打包工具| Electron NW.js cordova |
|11               | 生成器        | yeoman Slush vue-cli create-react-app |

### 3. 后端开发
<font color=#1E90FF>**① API 代理（API 网关）**</font>

一般后端开发指的是`Web`应用开发当中和视图渲染无关的部分，主要是以数据库交互为主的重业务逻辑处理，但是架构升级之后，`Node`承担了前后端分离的重任，就有了更多的玩法：
+ <font color=#CC99CD> 开发带视图的传统Web应用</font>（<font color=#3eaf7c>过去</font>）
+ <font color=#CC99CD>面向API的接口应用</font>（<font color=#3eaf7c>当前</font>）
+ <font color=#CC99CD>通过RPC调用封装对数据库进行操作</font>（<font color=#3eaf7c>（当前和未来）</font>）
+ <font color=#CC99CD>提供前端API代理（API Gateway）和网关，服务组装等</font> （<font color=#3eaf7c>当前和未来</font>）

`Web`应用大概分成两种：<font color=#CC99CD>带视图的传统Web应用</font>和<font color=#CC99CD>面向API接口的应用</font>，上述我们说4种玩法的后3种都属于以`API`为基础的面向`API`接口的应用。而面向接口的开发应用中如果时间过长或者项目太过复杂的时候就会产生下面的问题：
+ 一个页面的`API`非常多
+ 跨域
+ `API`返回的数据对前端不太友好
+ 需求临时决定需要一个`API`,但是`API`无法及时反馈

所以我们就会想：在包含多种交互的情况下。理想的情况是使用一样的模型，提供基于模型的定制`API`,在`Node`层提供统一的模型，然后包装成前端需要的`API`,这样的`API`是对前端友好的，所以就出现了<font color=#CC99CD>单节点API网关（API Gateway）</font>和<font color=#CC99CD>BFF网关（Node中间层）</font>

<img :src="$withBase('/node_api_gateway.png')" alt="API网关">

<font color=#CC99CD>这种API Proxy位于异构API（可能是RESTful API、可能是RPC服务）之前，通过对异构API进行抽象，形成模型层，然后根据各种前端的需求，包装成为对前端友好的API接口</font>

<font color=#1E90FF>**② 服务组装**</font>

在微服务架构十分流行的今天，服务化可谓是最佳实践，应用非常多的便是基于`TCP`的`RPC`服务，相比较`HTTP`来说效率更高，在结合配置中心，服务注册等，更好的对系统进行解耦，那么复杂的跨服务业务怎么处理，这个时候就需要对服务进行组装。而组装服务的过程也可以在`API Proxy`层进行实现：

<img :src="$withBase('/node_api_fuwuzuzhuang.jpeg')" alt="服务组装">

所以实际上服务组装的代价都一样，用`Node`为何不好呢？而且放在`Node Proxy`好处十分明显，既可以提高开发效率，又能让后端专注于服务开发，如果前端团队十分强大，可以组件一个`API`小组，从事服务集成的工作。

### 4. 更多流行应用
+ 搜索引擎优化 + 首屏速度优化 = 服务端渲染
+ 服务端渲染 + 前后端同构 = Node.js
+ 构建工作流其实使用各种技术都能做，而对于前端工程师使用来讲其实是需要经常对构建工具进行查询，修改的，所以使用`Node`是最保险的
+ 开发工具`VSCode`是基于`Node`技术的框架`Electron`构建的
+ 在已有网站的情况下需要新开发客户端应用，使用`Node`客户端技术`Electron`实现，可以最大限度实现复用

## 微服务
### 1. 微服务概述
<font color=#1E90FF>**① 什么是微服务**</font>

在传统的`Web`开发中，不会去区分前端后端，项目放在一个很大的仓库当中，面临的问题也随之而来：
+ <font color=#3eaf7c>仓库越来越大</font>
+ <font color=#3eaf7c>技术栈单一</font>
+ <font color=#3eaf7c>某个功能奔溃会导致全部项目奔溃</font>
+ <font color=#3eaf7c>项目难管理，代码冲突等等</font>

那么为了向更细小的方向划分业务，就出现了微服务，微服务本身不是什么新技术，只是随着业务的不断发展，对业务不断分层，不断拆分。它被业界公认为云计算时代互联网应用的主要构建方式，是每一位技术人员必须面对的主题。它的概念如下：
+ <font color=#1E90FF>微服务是系统或应用程序中的自包含独立组件。每个微服务都应该有明确的作用域和责任，理想情况下，一个微服务只做一件事。它应该是无状态的或有状态的，如果它是有状态的，它应该带有自己的持久层（即数据库），不与其他服务共享。软件开发团队基于微服务架构以更分散的方式开发可重用的独立组件。他们可以为每个微服务使用自定义框架、依赖关系集，甚至是完全不同的编程语言。微服务也有助于实现可扩展性，因为它们本质上是分布式的，并且每个微服务都可以独立增长或复制。</font>

<font color=#1E90FF>**② 容器和微服务**</font>

<font color=#3eaf7c>容器是在操作系统中建立隔离上下文的一种方法。实际上，这意味着它们中的每一个都有一个单独的包含了一组已安装的软件和相关配置的虚拟文件系统。由于它们是相互隔离的，因此任何容器都不能直接访问或影响其他容器或底层宿主操作系统。</font>

创建容器的能力已经成为`Linux`操作系统的一部分，这种能力已经存在了很长一段时间，但直到2013年Docker的推出，容器才成为一种流行的技术。

当我们在谈论定义时，需要注意的是微服务和容器其实是不一样的东西，但这两个概念经常被放在一起谈论，就像`API`和微服务一样。如果没有容器，要么把服务器配置成可以运行多个微服务，让这些微服务不可避免地相互产生负面干扰，要么每个微服务都需要一个单独的服务器或自己的虚拟机，导致不必要的开销。因此，微服务通常被部署在一组由容器集群软件（如 Kubernetes）管理的一组容器中。可以肯定地说，容器和微服务的崛起其实是相互影响、相互促进的结果。

<font color=#1E90FF>**③ 微服务之前的通信**</font>

基于微服务架构构建的应用程序或`API`不仅要把自己完全暴露出来，还需要在内部组件（微服务）之间建立连接。由于每个微服务都可以使用不同的编程语言实现，<font color=#CC99CD>我们需要依赖标准协议（如 HTTP）来建立微服务之间的连接</font>。这个时候我们就回到了`API`上，所以从这里也可以知道 <font color=#CC99CD>微服务是独立，可以使用任何技术去做，数据库也是相对独立的</font>。

最基本的形式是每个微服务都公开一个`API`，让其他服务可以向这个`API`发出请求并获取数据。也可以使用其他不同的方法，比如消息队列。微服务`API`是私有`API`，仅限用在单个应用程序中。它通常不提供公共`URL`，而是使用组织内部专用网络的私有`IP`或主机名，甚至是单个服务器集群内的`IP`或主机名。不过，这些`API`可以遵循类似公共`API`那样的设计范式或协议。而且，尽管它们的消费者数量有限，也应该遵循开发者体验的基本规则。也就是说，它们应该拥有相关的、一致的、可演化的`API`设计和文档，让其他团队（甚至是你自己）知道如何使用这些微服务。因此，你可以而且应该使用类似的工具来创建你的微服务`API`。

当然，与更面向外部的 API 相比，在设计微服务 API 时有不同的侧重点。

<img :src="$withBase('/node_weifuwu_tongxin.png')" alt="微服务之间的通信">

微服务和`API`是不同的东西，就像微服务和容器也不是同一种东西一样。不过，这两个概念以两种不同的方式协同工作：首先，微服务可以作为部署内部、合作伙伴或公共`API`后端的一种方法。其次，微服务通常依赖`API`作为与语言无关的通信手段，以便在内部网络中相互通信。开发团队可以使用相似的方法和工具来创建公开`API`和微服务`API`。

### 2. 网关和微服务
我们上面说过了微服务是部署在每个独立的容器当中，但是所有的微服务实际上在一个局域网之内，通信是靠`HTTP`相互调用微服务暴露出来的`API`,但是微服务是一定要暴露给外部用的，所以这里出现了`API`网关：

<img :src="$withBase('/node_api_weifuwu.png')" alt="网关和微服务">

在之前呢，不论是手机或者浏览器都是要直接调用整个服务服务，而现在是调用<font color=#CC99CD>网关</font>，网关说白了就是暴露给外网的一套API接口，或者说门神，然后网关再去调用一个一个微服务，而关于服务器有关的限流，熔断，负载均衡都能在网关这里去做，也是防止一个服务导致整个项目奔溃的解决方案。
